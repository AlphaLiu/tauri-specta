use heck::ToLowerCamelCase;
use indoc::formatdoc;
use std::{
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

use specta::{
    functions::FunctionDataType,
    ts::{self, TsExportError},
    ExportError, TypeDefs,
};

/// header returns the header of the TypeScript file.
pub fn header() -> String {
    formatdoc! {
        r#"
        // This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

        declare global {{
            interface Window {{
                __TAURI_INVOKE__<T>(cmd: string, args?: Record<string, unknown>): Promise<T>;
            }}
        }}

        const invoke = window.__TAURI_INVOKE__;
        "#
    }
}

/// render_functions a collection of [FunctionDataType] into a TypeScript string.
pub fn render_functions(
    function_types: Vec<FunctionDataType>,
    cfg: &specta::ts::ExportConfiguration,
) -> Result<String, TsExportError> {
    function_types
        .into_iter()
        .map(|function| {
            let name = &function.name;
            let name_camel = function.name.to_lower_camel_case();

            let arg_defs = function
                .args
                .iter()
                .map(|(name, typ)| {
                    ts::datatype(cfg, typ)
                        .map(|ty| format!("{}: {}", name.to_lower_camel_case(), ty))
                })
                .collect::<Result<Vec<_>, _>>()?
                .join(", ");

            let ret_type = ts::datatype(cfg, &function.result)?;

            let arg_usages = function
                .args
                .iter()
                .map(|(name, _)| name.to_lower_camel_case())
                .collect::<Vec<_>>();

            let arg_usages = arg_usages
                .is_empty()
                .then(Default::default)
                .unwrap_or_else(|| format!(", {{ {} }}", arg_usages.join(",")));

            Ok(formatdoc!(
                r#"

                export function {name_camel}({arg_defs}) {{
                    return invoke<{ret_type}>("{name}"{arg_usages})
                }}
            "#
            ))
        })
        .collect()
}

/// render combines the output of [header], [render_functions] and all of the dependant types into a single TypeScript string.
pub fn render(
    function_types: Vec<FunctionDataType>,
    type_map: TypeDefs,
    cfg: &specta::ts::ExportConfiguration,
) -> Result<String, TsExportError> {
    let functions = render_functions(function_types, cfg)?;

    let other_types = type_map
        .values()
        .filter_map(|v| v.as_ref())
        .map(|v| ts::export_datatype(cfg, v).map(|export| format!("\n{export}")))
        .collect::<Result<String, TsExportError>>()?;

    Ok(header() + &functions + &other_types)
}

/// Convert a collection of [FunctionDataType] into a TypeScript file which can be used on the frontend.
pub fn export_with_cfg(
    (function_types, type_map): (Vec<FunctionDataType>, TypeDefs),
    cfg: specta::ts::ExportConfiguration,
    export_path: impl AsRef<Path>,
) -> Result<(), TsExportError> {
    let export_path = PathBuf::from(export_path.as_ref());

    if let Some(export_dir) = export_path.parent() {
        fs::create_dir_all(export_dir)?;
    }

    let mut file = File::create(export_path)?;

    write!(file, "{}", render(function_types, type_map, &cfg)?)?;

    Ok(())
}

/// Convert a collection of [FunctionDataType] into a TypeScript file which can be used on the frontend.
pub fn export(
    macro_data: Result<(Vec<FunctionDataType>, TypeDefs), ExportError>,
    export_path: impl AsRef<Path>,
) -> Result<(), TsExportError> {
    export_with_cfg(macro_data?, Default::default(), export_path)
}
